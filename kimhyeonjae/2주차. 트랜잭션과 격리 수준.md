## 트랜잭션

> 💡 여러 작업들을 하나로 묶은 단위로, 이렇게 묶인 작업들은 모두 실행되거나 모두 실행되지 않는다(all-or-nothing). 

읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이라고 정의할 수 있다.

<br/>

하나의 트랜잭션 안에서 실패하면 트랜잭션 내부에서 했던 작업이 다시 진행하여도 동일한 결과를 얻을 수 있도록 트랜잭션의 처음으로 `rollback` 하여 내부에서 진행했던 작업을 초기화한다.

트랜잭션 내에서 실패하지 않고 정상적으로 동작을 하면 `commit` 을 통해 조작한 데이터를 실제적으로 적용한다.

<br/>

## ACID 특성

- #### 원자성(Atomicity)
    트랜잭션의 모든 연산이 정상적으로 수행 완료되거나 아니면 어떠한 연산도 수행되지 않는 원래 상태가 되도록 해야한다.
<br/>

- #### 일관성(Consistency)
    고립(동시에 수행되는 트랜잭션이 없는)상태에서 트랜잭션이 데이터베이스의 일관성을 보존해야 한다.
<br/>

- #### 고립성(Isolation)
    여러 트랜잭션이 동시에 수행된다 하더라도, 임의의 트랜잭션 $T_1$과 $T_2$ 쌍이 있을때 시스템은 $T_1$ 에게 $T_1$이 시작되기 전에 $T_2$ 수행을 마쳤거나 $T_1$이 종료된 후에 $T_2$ 가 수행을 시작하는 것과 같이 되도록 보장해야 한다.

    즉, 각각의 트랜잭션은 다른 트랜잭션이 동시에 수행되고 있는지 알지 못하는 것과 동일하게 해야한다.
<br/>

- #### 지속성(Durability)
    트랜잭션이 성공적으로 수행되면 시스템에 오류(정전, 네트워크 이슈 등등)가 발생한다 하더라도 영구적으로 반영되어야 한다.
<br/>


<br/><br/>

## 트랜잭션 격리 수준

> 💡 여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것. 

트랜잭션의 격리 수준은 격리(고립) 수준이 높은 순서대로 `SERIALIZABLE`, `REPEATABLE READ`, `READ COMMITTED`, `READ UNCOMMITED`가 존재한다.

<br/><br/>

### 1️⃣ SERIALIZABLE
> 가장 엄격한 격리수준. 이름 그대로 트랜잭션을 순차적으로 진행시킨다.

여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없으므로, **어떠한 데이터 부정합 문제도 발생하지 않는다**. 하지만 트랜잭션이 순차적으로 처리되어야 하므로 **동시 처리 성능이 매우 떨어진다**.
<br/>

MySQL에서 `SELECT ... FOR SHARE` , `SELECT ... FOR UPDATE` 는 대상 레코드에 각각 읽기 잠금 / 쓰기 잠금을 거는 것이다. 

일반 SELECT 문은 아무 레코드 잠금 없이 실행되고, 이를 잠금 없는 일관된 읽기(Non-locking consistent read) 라고 한다.
<br/>

하지만 SERIALIZABLE 격리 수준에서는 일반 SELECT 작업에서도 **대상 레코드에 넥스트 키 락을 읽기 잠금(공유락, Shared Lock)으로 건다**. 따라서 한 트랜잭션에서 넥스트 키 락이 걸린 레코드를 다른 트랜잭션에서는 절대 추가/수정/삭제할 수 없다. 

SERIALIZABLE은 가장 안전하지만 가장 성능이 떨어지므로, 극단적으로 안전한 작업이 필요한 경우가 아니라면 사용해서는 안된다.

<br/><br/>

### 2️⃣ REPEATABLE READ

> #### MVCC ( Multi Version Concurrency Control )
일반 RDBMS에서는 **변경 전 레코드를 언두 공간에 백업해둔다**. 이를 통해 변경 전/후 데이터가 모두 존재하므로, 동일한 레코드에 대해 여러 버전이 존재한다.

- 트랜잭션이 롤백된 경우에 데이터를 복원
- 서로 다른 트랜잭션 간에 접근할 수 있는 데이터를 세밀하게 제어
<br/>

각각의 **트랜잭션은 순차 증가하는 고유한 트랜잭션 번호가 존재**하며, 백업 레코드에는 어느 트랜잭션에 의해 백업되었는지 **트랜잭션 번호를 함께 저장**한다. 

해당 데이터가 불필요해진다고 판단하는 시점에 주기적으로 백그라운드 쓰레드를 통해 삭제한다.
<br/>

---
<br/>

**REPEATABLE READ**는 MVCC를 이용해 한 트랜잭션 내에서 동일한 결과를 보장하지만, 새로운 레코드가 추가되는 경우에 부정합이 생길 수 있다. 

> Ex) 트랜잭션을 시작하고, id = 10 이상인 레코드를 조회시 1건 조회되는 상황

![](https://velog.velcdn.com/images/kguswo/post/84bd990e-4371-484c-a8e5-9af5790b3835/image.png)
<br/>

다른 사용자 A의 트랜잭션에서 id=10인 레코드를 갱신하면 MVCC를 통해 기존 데이터는 변경되지만, 백업된 데이터가 언두 로그에 남게 된다.

![](https://velog.velcdn.com/images/kguswo/post/b9761aaf-02fd-4113-9434-a48d2c3d6bac/image.png)
<br/><br/>

이전에 사용자 B가 데이터를 조회했던 트랜잭션은 아직 종료되지 않은 상황에서, 사용자 B가 다시 한번 동일한 SELECT 문을 실행하면 어떻게 될까? 그 결과는 아래와 같다.

![](https://velog.velcdn.com/images/kguswo/post/9a8cc6e1-0d4b-440a-a7d3-493b7fe6a321/image.png)
<br/><br/>

사용자 B의 트랜잭션은(5) 사용자 A의 트랜잭션(10)이 시작하기 전에 이미 시작된 상태다.
이때 REPEATABLE READ는 트랜잭션 번호를 참고하여 **자신보다 먼저 실행된 트랜잭션의 데이터만을 조회한다**. 만약 테이블에 자신보다 이후에 실행된 트랜잭션의 데이터가 존재한다면 언두 로그를 참고해서 데이터를 조회한다.
<br/>

사용자 A의 트랜잭션이 시작되고 커밋까지 되었지만, 해당 트랜잭션(10)는 현재 트랜잭션(5)보다 나중에 실행되었기 때문에 조회 결과로 기존과 동일한 데이터를 얻게 된다. 

> **즉, `REPEATABLE READ`는 어떤 트랜잭션이 읽은 데이터를 다른 트랜잭션이 수정하더라도 동일한 결과를 반환할 것을 보장해준다**.

<br/>

앞서 설명하였듯 REPEATABLE READ는 새로운 레코드의 _**추가**_ 까지는 막지 않는다고 하였다. 따라서 **SELECT로 조회한 경우 트랜잭션이 끝나기 전에 다른 트랜잭션에 의해 `추가된 레코드`가 발견될 수 있는데, 이를 `Phantom Read(유령 읽기)`라고 한다**. 

하지만 MVCC 덕분에 일반적인 조회에서 유령 읽기(Phantom Read)는 발생하지 않는다. 왜냐하면 **자신보다 나중에 실행된 트랜잭션이 추가한 레코드는 무시**하면 되기 때문이다. 이러한 상황을 그림으로 표현하면 아래와 같다.

![](https://velog.velcdn.com/images/kguswo/post/198e623a-fd8f-4cc2-a188-44b4cb69d0eb/image.png)
<br/>

#### Q. 그렇다면 언제 유령 읽기가 발생하는 것일까? 
    
> **잠금이 사용되는 경우**이다.

MySQL은 다른 RDBMS와 다르게 특수한 갭 락이 존재하기 때문에, 동작이 다른 부분이 있으므로 일반적인 RDBMS 경우부터 살펴보도록 하자.
<br/>
> Ex) 사용자 B가 데이터 조회하는 경우 ( 잠금 사용 )

사용자B가 먼저 데이터를 조회하는데, 이번에는 `SELECT … FOR UPDATE` 를 이용해 쓰기 잠금을 걸었다. 

여기서 `SELECT … FOR UPDATE` 구문은 베타적 잠금(비관적 잠금, 쓰기 잠금)을 거는 것이다. 읽기 잠금을 걸려면 `SELECT ... FOR SHARE` 구문을 사용해야 한다. 락은 트랜잭션이 커밋 또는 롤백될 때 해제된다. 

```
읽기 잠금 : 데이터를 읽는 동안 다른 트랜잭션이 해당 데이터를 변경하지 못하도록 보호
쓰기 잠금 : 데이터를 독점적으로 사용하기 위해, 다른 트랜잭션의 읽기/쓰기 모두 차단
```

> 이후 사용자 A가 새로운 데이터를 INSERT하는 상황 

일반적인 DBMS에서는 갭락이 존재하지 않으므로 id = 10인 레코드만 잠금이 걸린 상태이고, 사용자 A의 요청은 잠금 없이 즉시 실행된다.

![](https://velog.velcdn.com/images/kguswo/post/40c6852c-5f91-4883-ba0e-8bb2cc4b2558/image.png)
<br/><br/>

이때 사용자 B가 동일한 쓰기 잠금 쿼리로 다시 한번 데이터를 조회하면, 이번에는 2건의 데이터가 조회된다. 동일한 트랜잭션 내에서도 새로운 레코드가 추가되는 경우에 조회 결과가 달라지는데, 이렇듯 다른 트랜잭션에서 수행한 작업에 의해 레코드가 안보였다 보였다 하는 현상을 `Phantom Read(유령 읽기)`라고 한다. 이는 다른 트랜잭션에서 새로운 레코드를 추가하거나 삭제하는 경우 발생할 수 있다.

![](https://velog.velcdn.com/images/kguswo/post/fee6ef3b-7fa4-405a-bdae-cb93a6e5d0e7/image.png)
<br/><br/>

따라서 `SELECT ... FOR UPDATE`나 `SELECT ... FOR SHARE`로 레코드를 조회하는 경우에는 **언두 영역의 데이터가 아니라 테이블의 레코드를 가져오게 되고, 이로 인해 `Phantom Read`가 발생하는 것**이다. 
<br/>

하지만 **MySQL에는 `Gap Lock(갭 락)` 이 존재하기 때문에 위의 상황에서 문제가 발생하지 않는다.**
사용자 B가 `SELECT ... FOR UPDATE`로 데이터를 조회한 경우에 MySQL은 id가 10인 레코드에는 레코드 락, id가 10보다 큰 범위에는 갭 락으로 넥스트 키 락을 건다. 

따라서 사용자 A가 id가 11인 user를 INSERT 시도한다면, B의 트랜잭션이 종료(커밋 또는 롤백)될 때 까지 기다리다가, 대기를 지나치게 오래 하면 락 타임아웃이 발생하게 된다.

![](https://velog.velcdn.com/images/kguswo/post/439ae59e-a225-45ff-8e21-1bf7290a90e6/image.png)
<br/><br/>

따라서 **일반적으로 MySQL의 `REAPEATABLE READ`에서는 `Phantom Read`가 발생하지 않는다.** 
<br/>


하지만 이러한 케이스는 거의 존재하지 않으므로, MySQL의 REPEATABLE READ에서는 PHANTOM READ가 발생하지 않는다고 봐도 된다. 

<br/><br/>

### 3️⃣ READ COMMITTED

> READ COMMITTED는 **커밋된 데이터만 조회**할 수 있다. 

READ COMMITTED는 REPEATABLE READ에서 발생하는 `Phantom Read`에 더해 `Non-Repeatable Read(반복 읽기 불가능)` 문제까지 발생한다.

> Ex) 사용자 A가 트랜잭션을 시작하여 어떤 데이터를 변경하였고, 아직 커밋은 하지 않은 상태

그러면 테이블은 먼저 갱신되고, 언두 로그로 변경 전의 데이터가 백업된다.

![](https://velog.velcdn.com/images/kguswo/post/07b1325d-22af-43b8-9765-c14411842180/image.png)

<br/><br/>

이때 사용자 B가 데이터를 조회하려고 하면, READ COMMITTED에서는 커밋된 데이터만 조회할 수 있으므로, REPEATABLE READ와 마찬가지로 언두 로그에서 변경 전의 데이터를 찾아서 반환하게 된다. 

최종적으로 사용자 A가 트랜잭션을 커밋하면 그때부터 다른 트랜잭션에서도 새롭게 변경된 값을 참조할 수 있는 것이다.

![](https://velog.velcdn.com/images/kguswo/post/6988adaa-bbda-45da-96aa-3bb7b938b9ab/image.png)
<br/><br/>

**하지만 READ COMMITTED는 Non-Repeatable Read(반복 읽기 불가능) 문제가 발생할 수 있다.**
> Ex) 사용자 B가 트랜잭션을 시작하고 name = “Grace”인 레코드를 조회하는 상황

해당 조건을 만족하는 레코드는 아직 존재하지 않으므로 아무 것도 반환되지 않는다.

![](https://velog.velcdn.com/images/kguswo/post/01de73cd-d28b-4a1b-b8e4-4cbe460d03f9/image.png)
<br/><br/>

그러다가 사용자 A가 UPDATE 문을 수행하여 해당 조건을 만족하는 레코드가 생겼다. 

사용자 A의 작업은 **커밋까지 완료된 상태**이다. 
#### Q. 사용자 B가 다시 동일한 조건으로 레코드를 조회하면 어떻게 될까? 

READ COMMITTED 는 커밋된 데이터는 조회할 수 있도록 허용하므로 결과가 나오게 된다.

![](https://velog.velcdn.com/images/kguswo/post/0f2c56b5-8b89-4553-8739-cd636030170f/image.png)

READ COMMITTED에서 반복 읽기를 수행하면 **다른 트랜잭션의 커밋 여부에 따라 조회 결과가 달라질 수 있다.** 따라서 이러한 데이터 부정합 문제를 `Non-Repeatable Read(반복 읽기 불가능)`라고 한다.
<br/>

Non-Repeatable Read는 일반적인 경우에는 크게 문제가 되지 않지만, 하나의 트랜잭션에서 동일한 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 생길 수 있다. 

<br/><br/>

### 4️⃣ READ UNCOMMITTED

> READ UNCOMMITTED는 **커밋하지 않은 데이터 조차도 접근할 수 있는 격리 수준이다.** 

READ UNCOMMITTED에서는 다른 트랜잭션의 작업이 커밋 또는 롤백되지 않아도 즉시 보이게 된다.
<br/>

> Ex) 사용자 A의 트랜잭션에서 INSERT를 통해 데이터를 추가하는 상황.

아직 커밋 또는 롤백이 되지 않은 상태임에도 불구하고 READ UNCOMMITTED는 변경된 데이터에 접근할 수 있다.

![](https://velog.velcdn.com/images/kguswo/post/0d8f110d-9c6b-4f12-be36-30485a70b41b/image.png)
<br/><br/>

이렇게 어떤 트랜잭션의 작업이 완료되지 않았는데도, 다른 트랜잭션에서 볼 수 있는 부정합 문제를 `Dirty Read(오손 읽기)`라고 한다. 

`Dirty Read`는 데이터가 조회되었다가 사라지는 현상을 초래하므로 시스템에 상당한 혼란을 주게 된다. 

#### Q. 만약 위의 경우에 사용자 A가 커밋이 아닌 롤백을 수행한다면 어떻게 될까?
![](https://velog.velcdn.com/images/kguswo/post/c2e253ab-cc3b-4798-9a38-e81507bebdbf/image.png)

사용자 B의 트랜잭션은 id = 11인 데이터를 계속 처리하고 있을 텐데, 다시 데이터를 조회하니 결과가 존재하지 않는 상황이 생긴다. 이러한 Dirty Read 상황은 시스템에 상당한 버그를 초래할 것이다.

그래서 READ UNCOMMITTED는 RDBMS 표준에서 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준이다. 따라서 MySQL을 사용한다면 최소한 `READ COMMITTED` 이상의 격리 수준을 사용해야 한다.
<br/>